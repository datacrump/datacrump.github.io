{"pageProps":{"post":{"slug":"file-formats","category":{"slug":"basics","title":"Basics","excerpt":"Basic stuff which you already know","coverImage":"/assets/logo.png","content":"","top":true},"title":"File formats","excerpt":"I was surpsided by results then comparing Parquet, Avro, JSON and CSV for both storage and speed","coverImage":"/assets/basics/file-formats/format_cover.png","cardImage":"/assets/basics/file-formats/format_card.png","date":"2022-10-20T20:36:35.000Z","contentPath":"/basics/file-formats.md","content":"<h2>tl;tr</h2>\n<p>Each file format has its own place in data engineering. You should choose one based on your project or workload.</p>\n<h2>preparing my data</h2>\n<p>I have pulled my data set from <a href=\"https://data.openaddresses.io/runs/1195253/lt/countrywide.zip\">https://data.openaddresses.io/runs/1195253/lt/countrywide.zip</a></p>\n<p>For my testing, I'll be using only a couple of columns so I have transformed the original file format to a new one.</p>\n<pre><code>{\n    'country': 'Lithuania',\n    'city': row['CITY'],\n    'postcode': int(row['POSTCODE'].replace(\"LT-\", \"\") if row['POSTCODE'] != ' ' else 0),\n    'street': f\"{' '.join(row['STREET'].split(' ')[1:])} {row['STREET'].split(' ')[0]}\",\n    'full_address': build_full_address(row),\n    'longitude': float(row['LON']),\n    'latitude': float(row['LAT'])\n}\n</code></pre>\n<p>I have added full_address column which joins street, city, and postcode.</p>\n<p>Data set has 1036250 rows</p>\n<h2>generating data files</h2>\n<h3>same dataset different formats</h3>\n<p>In the first step I took the original data and wrote it into different file formats:</p>\n<table>\n<thead>\n<tr>\n<th>Format</th>\n<th>Size</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>csv</td>\n<td>106MB</td>\n</tr>\n<tr>\n<td>json</td>\n<td>222MB</td>\n</tr>\n<tr>\n<td>avro</td>\n<td>24MB</td>\n</tr>\n<tr>\n<td>parquet</td>\n<td>32MB</td>\n</tr>\n</tbody>\n</table>\n<p>Both CSV and JSON are losing a lot compared to Avro and Parquet, however, this is expected because both Avro and Parquet are binary formats (they also use compression) while CSV and JSON are not compressed.</p>\n<p>To make this more comparable I will be applying compression for both JSON and CSV.</p>\n<p>Compression makes a difference</p>\n<table>\n<thead>\n<tr>\n<th>Format</th>\n<th>Original</th>\n<th>Compressed</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>csv</td>\n<td>106MB</td>\n<td>20MB</td>\n</tr>\n<tr>\n<td>json</td>\n<td>222MB</td>\n<td>22MB</td>\n</tr>\n<tr>\n<td>avro</td>\n<td>24MB</td>\n<td>24MB</td>\n</tr>\n<tr>\n<td>parquet</td>\n<td>32MB</td>\n<td>32MB</td>\n</tr>\n</tbody>\n</table>\n<p>Moving forward I'll be using compressed files for comparison</p>\n<h3>shuffle some data</h3>\n<p>My initial data set was already sorted, I will shuffle it to make a more realistic.</p>\n<table>\n<thead>\n<tr>\n<th>Format</th>\n<th>Original</th>\n<th>Shuffle</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>csv</td>\n<td>20MB</td>\n<td>34MB</td>\n</tr>\n<tr>\n<td>json</td>\n<td>22MB</td>\n<td>40MB</td>\n</tr>\n<tr>\n<td>avro</td>\n<td>24MB</td>\n<td>45MB</td>\n</tr>\n<tr>\n<td>parquet</td>\n<td>32MB</td>\n<td>44MB</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"/assets/basics/file-formats/size.png\" alt=\"creat bucket\"></p>\n<p>Shuffle has affected the overall size for all formats. I surprised it Avro has the most significant impact. It increased by 88%. Parquet is a clear winner here with data increase only by 38%</p>\n<p><img src=\"/assets/basics/file-formats/increase.png\" alt=\"creat bucket\"></p>\n<h3>5x</h3>\n<p>For speed testing, I wanted to have more data. So I replicate data 5 times and the final dataset was again shuffled.</p>\n<table>\n<thead>\n<tr>\n<th>Format</th>\n<th>Original</th>\n<th>Shuffle</th>\n<th>5x</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>csv</td>\n<td>20MB</td>\n<td>34MB</td>\n<td>168MB</td>\n</tr>\n<tr>\n<td>json</td>\n<td>22MB</td>\n<td>40MB</td>\n<td>198MB</td>\n</tr>\n<tr>\n<td>avro</td>\n<td>24MB</td>\n<td>45MB</td>\n<td>222MB</td>\n</tr>\n<tr>\n<td>parquet</td>\n<td>32MB</td>\n<td>44MB</td>\n<td>215MB</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>No surprises here...</p>\n</blockquote>\n<h2>query speed</h2>\n<p>For my testing, I'm using Apache Spark. I load all data types into the data frame and register it as TempView.</p>\n<blockquote>\n<p>we will be testing queries... we must have tables and SQL!!!</p>\n</blockquote>\n<pre><code>#parquet\ndf = spark.read.parquet('data/parquet/data_5x.parquet')\ndf.createOrReplaceTempView('source_table')\n\n#csv\ndf = spark.read.format(\"csv\").option(\"header\",\"true\").load('data/csv/data_5x.csv.gz')\ndf.createOrReplaceTempView('source_table')\n\n#json\ndf = spark.read.option(\"multiline\", \"true\").json(\"data/json/data_5x.json.gz\")\ndf.createOrReplaceTempView('source_table')\n\n#avro\ndf = spark.read.format(\"avro\").load(\"data/avro/data_5x.avro\")\ndf.createOrReplaceTempView('source_table')\n</code></pre>\n<p>I came up with a list of queries.</p>\n<blockquote>\n<p>if you have a query suggestion - please leave it in the comments on social media.</p>\n</blockquote>\n<p>queries:</p>\n<pre><code>#Q1: \nselect count(*) as cnt from source_table\n\n#Q2: \nselect count(distinct full_address) as cnt from source_table\n\n#Q3:\nselect count(distinct full_address) as cnt from source_table where city = 'Vilnius'\n\n#Q4:\nselect city, count(distinct full_address) as cnt from source_table group by 1 order by cnt desc\n\n#Q5:\nselect count(*) from source_table where city = 'Vilnius' and street = 'Kauno gatvė'\n\n#Q6:\nselect count(*) from source_table where full_address like '%Liep%' \n</code></pre>\n<p>Results:</p>\n<table>\n<thead>\n<tr>\n<th>Query</th>\n<th>csv</th>\n<th>json</th>\n<th>avro</th>\n<th>parquet</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>q1</td>\n<td>04.711</td>\n<td>11.782</td>\n<td>00.498</td>\n<td>00.103</td>\n</tr>\n<tr>\n<td>q2</td>\n<td>12.945</td>\n<td>16.360</td>\n<td>01.986</td>\n<td>03.132</td>\n</tr>\n<tr>\n<td>q3</td>\n<td>09.654</td>\n<td>14.645</td>\n<td>00.795</td>\n<td>01.240</td>\n</tr>\n<tr>\n<td>q4</td>\n<td>14.365</td>\n<td>18.031</td>\n<td>02.795</td>\n<td>04.463</td>\n</tr>\n<tr>\n<td>q5</td>\n<td>08.252</td>\n<td>14.008</td>\n<td>00.480</td>\n<td>00.628</td>\n</tr>\n<tr>\n<td>q6</td>\n<td>08.831</td>\n<td>14.004</td>\n<td>00.544</td>\n<td>00.977</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"/assets/basics/file-formats/graph.png\" alt=\"creat bucket\"></p>\n<p>Parquet and Avro are clear winners for running queries</p>\n<h2>summary</h2>\n<p>CSV - can be compressed very well. This format's ancient - so you should not have a problem reading it.</p>\n<blockquote>\n<p>I would choose this format for moving data via FTP or email.</p>\n</blockquote>\n<p>Avro - I knew nothing about it before starting my tests, it is a row-based format while parquet is columnar.</p>\n<blockquote>\n<p>I think it would be perfect for storing data consumed by Kafka</p>\n</blockquote>\n<p>JSON - having schema in each row is not efficient... for it, you pay with speed and size.  However at the same time if your schema is evolving you do not need to do anything.</p>\n<blockquote>\n<p>I still like this format because of how easy it is to deal with it</p>\n</blockquote>\n<p>Parquet - I was expecting a little bit more from it (was really surprised by Avro's performance).</p>\n<blockquote>\n<p>I'm still shocked it was beaten by Avro :D</p>\n</blockquote>\n<p>I think all of these formats will continue to be used.</p>\n","top":true,"visible":true,"tags":[{"slug":"storage","title":"Storage","excerpt":"","coverImage":"/assets/logo.png","content":""}]},"category":{"slug":"basics","title":"Basics","excerpt":"Basic stuff which you already know","coverImage":"/assets/logo.png","content":"","top":true},"posts":[{"slug":"storage","category":{"slug":"basics","title":"Basics","excerpt":"Basic stuff which you already know","coverImage":"/assets/logo.png","content":"","top":true},"title":"Object vs block store","excerpt":"Cheap, scalable, and yet is it really the best storage type for your next big data project","coverImage":"/assets/basics/storage/storage_cover.png","cardImage":"/assets/basics/storage/storage_card.png","date":"2022-10-13T12:36:35.000Z","contentPath":"/basics/storage.md","content":"## what is\n\n### object storage\n\nAWS simple storage service (S3) - is the best know object-store. However, it’s not the only provider of object storage, other choices:\n- Azure Blob storage\n- Google cloud storage (GCS)\n- DigitalOcean spaces\n\n> search for object store providers you might have found one in your home town :) \n\n### block storage\n\nI think the easiest way to think about block storage - it's an HDD or SSD or NVRAM which you can attach to your running instance in the cloud. Each cloud provider does have a version of it.\n\n## usage\n\nIf your project is Netflix, Spotify, or a book library - in which your objects need to be returned to the user full - object store might be a perfect solution.\n\n### object store for database\n\n> amount of data you need to read is directly responsible for your database performance\n\nThe parquet file is split into row groups which contain columns and meta information about it. Readers are expected to first read the file metadata to find all the column chunks they are interested in. The column chunks should then be read sequentially. The format is explicitly designed to separate the metadata from the data.\n\nHowever to achieve this storage needs to support the ability to read chunks of files, this is easily achievable in block storage because the operating system supports this. \n\nObject storage on the other hand returns all or nothing for a given key. In S3 there is a way to seek, however HTTP protocol is not as fast as direct access storage provided by the operating system.\n\nAt least right now many databases which are based on object storage - first need to download a file to local storage (block storage) and then process it the same way.\n\nOf course, this is not the case if your files are JSON or CSV. The computation engine needs to read a full file to be able to parse information from it. If you need to read the full file object store is a very good solution.\n\n## which one to chooce\n\nfor near realtime data retrieval - block storage\n\nfor data lake or unstructured data - object store\n\n## additional info\n\n### pricing \n\nBlock storage at a minimum twice expensive compared to object-store.\n\n| Type | Product | Price per TB / month |\n| -----| ------------ | -------------------- |\n| Object | AWS S3   | around $23   |\n| Object | GCS     | around $23    |\n| Block | EBS     | starts at $80    |\n| Block | Google Disk     | starts at $44    |\n\n### access layer\n\nObject sore - HTTP protocol\n\nBlock storage - operating system\n\n## summary\n\nBoth object and block storage has it's use cases and very often you will need to go with a mixture of both\n\n> what fits everything very often doesn't fit anything\n","top":true,"visible":true,"tags":[{"slug":"aws","title":"AWS","excerpt":"","coverImage":"/assets/logo.png","content":""},{"slug":"storage","title":"Storage","excerpt":"","coverImage":"/assets/logo.png","content":""}]}]},"__N_SSG":true}